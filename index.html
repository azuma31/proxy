<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ウェブプロキシ - 学校側</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>ウェブプロキシ - 学校側</h1>

        <div class="input-group">
            <label for="homePeerId">家のPeer ID:</label>
            <input type="text" id="homePeerId" placeholder="家側のPeer IDを入力してください">
        </div>

        <div class="input-group">
            <label for="url">URL:</label>
            <input type="text" id="url" placeholder="アクセスしたいURLを入力してください">
        </div>

        <button id="connectBtn">接続</button>
        <button id="fetchBtn" disabled>データ取得</button>

        <div id="statusMsg" class="status disconnected">未接続</div>

        <div id="loadingIndicator">
            <div class="spinner"></div>
            <span id="loadingText">データ取得中...</span>
        </div>

        <div id="progressContainer" class="progress-container">
            <div id="progressBar" class="progress-bar">
                <div id="progressText" class="progress-text">0%</div>
            </div>
        </div>

        <div id="processingSteps" class="processing-steps">
            <div id="stepReceiving" class="step step-pending">
                <span class="step-icon">◯</span>データ受信
            </div>
            <div id="stepParsing" class="step step-pending">
                <span class="step-icon">◯</span>HTML解析
            </div>
            <div id="stepProcessing" class="step step-pending">
                <span class="step-icon">◯</span>リンク処理
            </div>
            <div id="stepRendering" class="step step-pending">
                <span class="step-icon">◯</span>ページレンダリング
            </div>
        </div>

        <div id="resultContainer">
            <div class="tabs">
                <div class="tab active" data-tab="preview">プレビュー</div>
                <div class="tab" data-tab="source">ソース</div>
            </div>

            <div id="metaInfo" class="meta-info" style="display:none">
                <div class="meta-row">
                    <div class="meta-label">URL:</div>
                    <div id="metaUrl" class="meta-value"></div>
                </div>
                <div class="meta-row">
                    <div class="meta-label">ステータス:</div>
                    <div id="metaStatus" class="meta-value"></div>
                </div>
                <div class="meta-row">
                    <div class="meta-label">タイトル:</div>
                    <div id="metaTitle" class="meta-value"></div>
                </div>
                <div class="meta-row">
                    <div class="meta-label">Content-Type:</div>
                    <div id="metaContentType" class="meta-value"></div>
                </div>
                <div class="meta-row">
                    <div class="meta-label">リソース数:</div>
                    <div id="metaResourceCount" class="meta-value">0</div>
                </div>
                <div class="meta-row">
                    <div class="meta-label">処理時間:</div>
                    <div id="metaProcessingTime" class="meta-value">-</div>
                </div>
                <div class="meta-row">
                    <div class="meta-label">クライアント処理:</div>
                    <div id="metaClientProcessing" class="meta-value">-</div>
                </div>
            </div>

            <div class="control-buttons">
                <button id="refreshPageBtn" style="display:none;">ページを更新</button>
                <button id="copySourceBtn" style="display:none;">ソースをコピー</button>
                <button id="backBtn" style="display:none;">戻る</button>
                <button id="forwardBtn" style="display:none;">進む</button>
            </div>

            <div id="previewTab" class="tab-content active">
                <iframe id="previewFrame" sandbox="allow-same-origin allow-scripts"></iframe>
            </div>

            <div id="sourceTab" class="tab-content">
                <textarea id="sourceContent" readonly></textarea>
            </div>
        </div>
    </div>

    <!-- HTMLパーサーワーカー (修正版) -->
    <script id="htmlParserWorker" type="javascript/worker">
        // Web Worker内のコード
        self.onmessage = function(e) {
            const { type, data } = e.data;

            if (type === 'parseHTML') {
                try {
                    // HTMLパース処理開始
                    self.postMessage({ type: 'status', status: 'parsing' });

                    const { html, url, metaData } = data;

                    // DOMParserはWeb Workerで使用できないため、正規表現で簡易的にリンクを抽出
                    const linkPattern = /<a\s+(?:[^>]*?\s+)?href=["']([^"']*)["'][^>]*>(.*?)<\/a>/gi;
                    let match;
                    const links = [];

                    while ((match = linkPattern.exec(html)) !== null) {
                        links.push({
                            href: match[1],
                            text: match[2].replace(/<[^>]*>/g, '') // タグを除去
                        });
                    }

                    // base要素を追加または更新
                    let processedHtml = html;
                    if (processedHtml.includes('<base')) {
                        processedHtml = processedHtml.replace(/<base[^>]*>/i, `<base href="${url}">`);
                    } else {
                        processedHtml = processedHtml.replace(/<head[^>]*>/i, `<head><base href="${url}">`);
                    }

                    // カスタムスクリプトを挿入して、リンククリックを捕捉
                    const linkInterceptorScript = `
                    <script>
                    document.addEventListener('click',function(e){const t=e.target.closest('a');t&&t.href&&(e.preventDefault(),window.parent.postMessage({type:'linkClicked',url:t.href},'*'))});
                    <\/script>
                    `;

                    // </body>タグの前にスクリプトを挿入
                    if (processedHtml.includes('</body>')) {
                        processedHtml = processedHtml.replace('</body>', `${linkInterceptorScript}</body>`);
                    } else {
                        processedHtml += linkInterceptorScript;
                    }

                    // 処理完了
                    self.postMessage({
                        type: 'result',
                        processedHtml,
                        links,
                        url,
                        metaData
                    });

                } catch (error) {
                    self.postMessage({
                        type: 'error',
                        error: error.message
                    });
                }
            }
        };
    </script>

    <script>
        // グローバル変数を最小限に保ち、必要なものだけ維持
        let peer;
        let conn;
        let myPeerId;
        let currentUrl = '';
        let currentHtmlContent = '';
        let htmlParserWorker = null;
        let history = [];
        let currentHistoryIndex = -1;
        let processingStart = 0;
        let isProcessing = false;

        // DOM要素の参照を最初に一度だけ取得し変数に保存
        const homePeerIdInput = document.getElementById('homePeerId');
        const urlInput = document.getElementById('url');
        const connectBtn = document.getElementById('connectBtn');
        const fetchBtn = document.getElementById('fetchBtn');
        const statusMsg = document.getElementById('statusMsg');
        const previewFrame = document.getElementById('previewFrame');
        const sourceContent = document.getElementById('sourceContent');
        const metaInfo = document.getElementById('metaInfo');
        const metaUrl = document.getElementById('metaUrl');
        const metaStatus = document.getElementById('metaStatus');
        const metaTitle = document.getElementById('metaTitle');
        const metaContentType = document.getElementById('metaContentType');
        const metaResourceCount = document.getElementById('metaResourceCount');
        const metaProcessingTime = document.getElementById('metaProcessingTime');
        const metaClientProcessing = document.getElementById('metaClientProcessing');
        const refreshPageBtn = document.getElementById('refreshPageBtn');
        const copySourceBtn = document.getElementById('copySourceBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const backBtn = document.getElementById('backBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const processingSteps = document.getElementById('processingSteps');
        // 処理ステップの要素
        const stepReceiving = document.getElementById('stepReceiving');
        const stepParsing = document.getElementById('stepParsing');
        const stepProcessing = document.getElementById('stepProcessing');
        const stepRendering = document.getElementById('stepRendering');

        // Web Workerの初期化関数を最適化
        function initHtmlParserWorker() {
            // 既存のワーカーを終了
            if (htmlParserWorker) {
                htmlParserWorker.terminate();
            }

            // ワーカースクリプトを一度だけ取得
            const workerScript = document.getElementById('htmlParserWorker').textContent;
            const blob = new Blob([workerScript], { type: 'text/javascript' });
            const workerUrl = URL.createObjectURL(blob);

            // ワーカーを作成
            htmlParserWorker = new Worker(workerUrl);

            // メッセージハンドラの最適化
            htmlParserWorker.onmessage = function (e) {
                const { type, status, processedHtml, url, metaData, error } = e.data;

                if (type === 'status' && status === 'parsing') {
                    // パース中の視覚的フィードバックを最小限に
                    if (processingSteps.style.display !== 'none') {
                        stepParsing.className = 'step step-active';
                        stepParsing.querySelector('.step-icon').textContent = '✓';
                        stepReceiving.className = 'step step-completed';
                        stepReceiving.querySelector('.step-icon').textContent = '✓';
                    }
                }
                else if (type === 'result') {
                    // 処理ステップの視覚的フィードバックを最小限に
                    if (processingSteps.style.display !== 'none') {
                        stepProcessing.className = 'step step-active';
                        stepProcessing.querySelector('.step-icon').textContent = '✓';
                        stepParsing.className = 'step step-completed';
                    }

                    // HTML表示方法をsrcdocに戻す (より確実な表示を優先)
                    previewFrame.srcdoc = processedHtml;

                    // 現在のURLを更新
                    currentUrl = url;

                    // ページが表示されたことを確認するためのタイマー設定
                    setTimeout(() => {
                        if (processingSteps.style.display !== 'none') {
                            stepRendering.className = 'step step-completed';
                            stepRendering.querySelector('.step-icon').textContent = '✓';
                            stepProcessing.className = 'step step-completed';

                            // 処理完了後、ステップ表示を非表示にする
                            setTimeout(() => {
                                processingSteps.style.display = 'none';
                            }, 500);
                        }

                        // 処理時間の計算
                        const clientProcessingEnd = performance.now();
                        const clientProcessingTime = (clientProcessingEnd - processingStart) / 1000;
                        metaClientProcessing.textContent = `${clientProcessingTime.toFixed(2)}秒`;

                        // 処理状態をリセット
                        isProcessing = false;

                        // UI要素を更新
                        fetchBtn.disabled = false;
                        loadingIndicator.style.display = 'none';
                        progressContainer.style.display = 'none';
                    }, 500);

                    // イベントリスナーを設定（リンククリック用）
                    window.addEventListener('message', handleIframeMessage);
                    refreshPageBtn.style.display = 'inline-block';
                }
                else if (type === 'error') {
                    console.error('HTMLパーサーエラー:', error);
                    statusMsg.textContent = `HTML処理エラー: ${error}`;
                    loadingIndicator.style.display = 'none';
                    progressContainer.style.display = 'none';
                    processingSteps.style.display = 'none';
                    isProcessing = false;
                    fetchBtn.disabled = false;
                }
            };

            // エラーハンドリングを簡素化
            htmlParserWorker.onerror = function (error) {
                console.error('Web Workerエラー:', error);
                statusMsg.textContent = 'HTML処理中にエラーが発生しました';
                loadingIndicator.style.display = 'none';
                progressContainer.style.display = 'none';
                processingSteps.style.display = 'none';
                isProcessing = false;
                fetchBtn.disabled = false;
            };
        }

        // iframe内のメッセージハンドラを最適化
        function handleIframeMessage(event) {
            const { type, url } = event.data || {};

            if (type === 'linkClicked' && !isProcessing) {
                let clickedUrl = url;

                // 相対URLの場合は絶対URLに変換
                if (clickedUrl && !clickedUrl.startsWith('http')) {
                    try {
                        clickedUrl = new URL(clickedUrl, currentUrl).href;
                    } catch (e) {
                        console.error('URL変換エラー:', e);
                        return;
                    }
                }

                // URLを設定して新しいページをロード
                if (clickedUrl) {
                    urlInput.value = clickedUrl;
                    fetchData();
                }
            }
        }

        // 処理ステップの更新関数を簡素化（必要な場合のみ呼び出す）
        function updateProcessingStep(step) {
            // ステップ表示が非表示の場合は処理をスキップ
            if (processingSteps.style.display === 'none') return;

            // すべてのステップをリセット
            stepReceiving.className = 'step step-pending';
            stepParsing.className = 'step step-pending';
            stepProcessing.className = 'step step-pending';
            stepRendering.className = 'step step-pending';

            stepReceiving.querySelector('.step-icon').textContent = '◯';
            stepParsing.querySelector('.step-icon').textContent = '◯';
            stepProcessing.querySelector('.step-icon').textContent = '◯';
            stepRendering.querySelector('.step-icon').textContent = '◯';

            // 現在のステップに応じた表示に更新
            switch (step) {
                case 'receiving':
                    stepReceiving.className = 'step step-active';
                    break;
                case 'parsing':
                    stepReceiving.className = 'step step-completed';
                    stepParsing.className = 'step step-active';
                    stepReceiving.querySelector('.step-icon').textContent = '✓';
                    break;
                case 'processing':
                    stepReceiving.className = 'step step-completed';
                    stepParsing.className = 'step step-completed';
                    stepProcessing.className = 'step step-active';
                    stepReceiving.querySelector('.step-icon').textContent = '✓';
                    stepParsing.querySelector('.step-icon').textContent = '✓';
                    break;
                case 'rendering':
                    stepReceiving.className = 'step step-completed';
                    stepParsing.className = 'step step-completed';
                    stepProcessing.className = 'step step-completed';
                    stepRendering.className = 'step step-active';
                    stepReceiving.querySelector('.step-icon').textContent = '✓';
                    stepParsing.querySelector('.step-icon').textContent = '✓';
                    stepProcessing.querySelector('.step-icon').textContent = '✓';
                    break;
                case 'complete':
                    stepReceiving.className = 'step step-completed';
                    stepParsing.className = 'step step-completed';
                    stepProcessing.className = 'step step-completed';
                    stepRendering.className = 'step step-completed';
                    stepReceiving.querySelector('.step-icon').textContent = '✓';
                    stepParsing.querySelector('.step-icon').textContent = '✓';
                    stepProcessing.querySelector('.step-icon').textContent = '✓';
                    stepRendering.querySelector('.step-icon').textContent = '✓';

                    // 完了後、ステップ表示を非表示にする
                    setTimeout(() => {
                        processingSteps.style.display = 'none';
                    }, 500);
                    break;
            }
        }

        // データ取得関数を効率化
        function fetchData() {
            const url = urlInput.value.trim();
            if (!url || isProcessing) return;

            isProcessing = true;
            processingStart = performance.now();

            // 履歴に追加
            if (currentUrl !== url) {
                // 新しいURLの場合、現在位置より後の履歴を削除
                if (currentHistoryIndex >= 0) {
                    history = history.slice(0, currentHistoryIndex + 1);
                }
                history.push(url);
                currentHistoryIndex = history.length - 1;
                updateNavigationButtons();
            }

            currentUrl = url;

            // UI更新
            statusMsg.textContent = 'データ取得中...';
            statusMsg.className = 'status loading';
            fetchBtn.disabled = true;
            loadingIndicator.style.display = 'block';
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            progressText.textContent = '0%';

            // 最小限のUI更新で処理ステップを表示
            processingSteps.style.display = 'block';
            updateProcessingStep('receiving');

            // プレビュー関連のクリーンアップ
            previewFrame.srcdoc = '';
            sourceContent.value = '';
            metaInfo.style.display = 'none';
            refreshPageBtn.style.display = 'none';

            // データ取得リクエスト送信
            conn.send({
                type: 'fetch',
                url: url
            });
        }

        // 結果の処理を高速化
        function processResult(content) {
            if (content.startsWith('エラー:')) {
                // エラーメッセージの表示
                sourceContent.value = content;
                previewFrame.srcdoc = `<html><body><h1>エラー</h1><p>${content}</p></body></html>`;
                processingSteps.style.display = 'none';
                isProcessing = false;
                fetchBtn.disabled = false;
                return;
            }

            // メタデータとHTMLコンテンツを抽出（正規表現を一度だけ実行）
            const metaDataMatch = content.match(/URL: (.*?)\nステータス: (.*?)\nタイトル: (.*?)\nコンテンツタイプ: (.*?)\nエンコーディング: (.*?)\nリソース数: (.*?)\n処理時間: (.*?)\n\n--- HTML コンテンツ ---\n([\s\S]*)/);

            if (metaDataMatch) {
                const [, url, status, title, contentType, encoding, resourceCount, processingTime, htmlContent] = metaDataMatch;

                // メタデータを一度に更新（バッチ更新）
                metaUrl.textContent = url;
                metaStatus.textContent = status;
                metaTitle.textContent = title;
                metaContentType.textContent = contentType;
                metaResourceCount.textContent = resourceCount;
                metaProcessingTime.textContent = processingTime;
                metaInfo.style.display = 'block';

                // 現在のHTMLコンテンツを保存
                currentHtmlContent = htmlContent;

                // ソースコードを表示
                sourceContent.value = htmlContent;

                // メタデータオブジェクトを一度だけ作成
                const metaDataObj = { url, status, title, contentType, encoding, resourceCount, processingTime };

                // HTMLパーサーWorkerにタスクを送信
                htmlParserWorker.postMessage({
                    type: 'parseHTML',
                    data: {
                        html: htmlContent,
                        url: url,
                        metaData: metaDataObj
                    }
                });
            } else {
                // メタデータの抽出に失敗した場合
                processingSteps.style.display = 'none';
                sourceContent.value = content;

                // HTMLエスケープを効率的に行う
                const escapedContent = content
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');

                previewFrame.srcdoc = `<html><body><pre>${escapedContent}</pre></body></html>`;
                isProcessing = false;
                fetchBtn.disabled = false;
            }
        }

        // 進捗状況の更新を効率化
        function updateProgress(percent) {
            if (progressContainer.style.display !== 'block') return;

            // CSSアニメーションを使わず直接値を設定
            progressBar.style.width = `${percent}%`;
            progressText.textContent = `${percent}%`;
        }

        // ナビゲーションボタンの更新を最適化
        function updateNavigationButtons() {
            backBtn.disabled = currentHistoryIndex <= 0;
            forwardBtn.disabled = currentHistoryIndex >= history.length - 1;
        }

        // Peer接続の初期化を最適化
        function initPeer() {
            peer = new Peer({
                // バッファサイズを大きくして高速化
                config: {
                    'iceServers': [{ urls: 'stun:stun.l.google.com:19302' }],
                    'sdpSemantics': 'unified-plan'
                },
                // 大きなファイル転送を効率化
                serialization: 'binary'
            });

            peer.on('open', (id) => {
                myPeerId = id;
                statusMsg.textContent = `学校側のPeer ID: ${id}`;
                statusMsg.className = 'status disconnected';
            });

            peer.on('error', (err) => {
                console.error(err);
                statusMsg.textContent = `エラー: ${err.message}`;
                statusMsg.className = 'status disconnected';
                connectBtn.disabled = false;
                fetchBtn.disabled = true;
                loadingIndicator.style.display = 'none';
                progressContainer.style.display = 'none';
                processingSteps.style.display = 'none';
                isProcessing = false;
            });
        }

        // 家側PCへの接続処理を最適化
        function connectToHome() {
            const homePeerId = homePeerIdInput.value.trim();
            if (!homePeerId) {
                alert('家側のPeer IDを入力してください');
                return;
            }

            statusMsg.textContent = '接続中...';
            statusMsg.className = 'status loading';
            connectBtn.disabled = true;

            // 接続オプションの最適化
            conn = peer.connect(homePeerId, {
                reliable: true,
                serialization: 'binary', // バイナリデータ転送を使用
                // バッファサイズを増やして転送効率化
                metadata: { type: 'school-client' }
            });

            conn.on('open', () => {
                statusMsg.textContent = '接続成功！';
                statusMsg.className = 'status connected';
                connectBtn.disabled = true;
                fetchBtn.disabled = false;
                backBtn.style.display = 'inline-block';
                forwardBtn.style.display = 'inline-block';
                updateNavigationButtons();

                // Web Workerの初期化（遅延初期化に変更）
                initHtmlParserWorker();

                // データ受信ハンドラの最適化
                conn.on('data', (data) => {
                    if (data.type === 'result') {
                        processingStart = performance.now();
                        processResult(data.content);
                        statusMsg.textContent = '取得完了';
                        statusMsg.className = 'status connected';
                    } else if (data.type === 'progress') {
                        // 進捗状況を更新（最小限の更新）
                        updateProgress(data.percent);
                    }
                });
            });

            // エラーハンドリングの簡略化
            conn.on('close', () => {
                statusMsg.textContent = '接続が切断されました';
                statusMsg.className = 'status disconnected';
                connectBtn.disabled = false;
                fetchBtn.disabled = true;
                backBtn.style.display = 'none';
                forwardBtn.style.display = 'none';
                isProcessing = false;
            });

            conn.on('error', (err) => {
                console.error(err);
                statusMsg.textContent = `接続エラー: ${err.message}`;
                statusMsg.className = 'status disconnected';
                connectBtn.disabled = false;
                fetchBtn.disabled = true;
                loadingIndicator.style.display = 'none';
                progressContainer.style.display = 'none';
                processingSteps.style.display = 'none';
                isProcessing = false;
            });
        }

        // DOMContentLoadedイベントで必要最小限の初期化を行う
        document.addEventListener('DOMContentLoaded', () => {
            // Peer接続の初期化
            initPeer();

            // イベントリスナーの設定（イベント委任を使用）
            connectBtn.addEventListener('click', connectToHome);
            fetchBtn.addEventListener('click', fetchData);
            refreshPageBtn.addEventListener('click', () => currentUrl && fetchData());
            copySourceBtn.addEventListener('click', () => {
                sourceContent.select();
                document.execCommand('copy');
            });
            backBtn.addEventListener('click', () => {
                if (currentHistoryIndex > 0) {
                    currentHistoryIndex--;
                    urlInput.value = history[currentHistoryIndex];
                    fetchData();
                    updateNavigationButtons();
                }
            });
            forwardBtn.addEventListener('click', () => {
                if (currentHistoryIndex < history.length - 1) {
                    currentHistoryIndex++;
                    urlInput.value = history[currentHistoryIndex];
                    fetchData();
                    updateNavigationButtons();
                }
            });

            // タブ切り替えのイベント委任
            document.querySelector('.tabs').addEventListener('click', (e) => {
                if (e.target.classList.contains('tab')) {
                    // タブ切り替え
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                    // クリックしたタブをアクティブに
                    e.target.classList.add('active');
                    document.getElementById(e.target.dataset.tab + 'Tab').classList.add('active');

                    // ソースタブ選択時のコピーボタン表示制御
                    copySourceBtn.style.display = e.target.dataset.tab === 'source' ? 'inline-block' : 'none';
                }
            });

            // Enterキーでの送信対応
            urlInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !fetchBtn.disabled) {
                    fetchData();
                }
            });
        });
    </script>
</body>
</html>