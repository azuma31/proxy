<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Web Proxy Viewer</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e40af;
            --success-color: #16a34a;
            --error-color: #dc2626;
            --background-color: #f1f5f9;
            --surface-color: #ffffff;
            --text-color: #1e293b;
            --border-color: #e2e8f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.5;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem;
        }

        .header {
            background-color: var(--surface-color);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
        }

            .header h1 {
                font-size: 1.5rem;
                color: var(--text-color);
                margin-bottom: 1rem;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

                .header h1 i {
                    color: var(--primary-color);
                }

        .control-panel {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .url-input {
            flex: 1;
            display: flex;
            gap: 0.5rem;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            padding: 0.25rem;
            border-radius: 6px;
            align-items: center;
        }

            .url-input i {
                color: var(--text-color);
                padding: 0 0.5rem;
            }

            .url-input input {
                flex: 1;
                border: none;
                padding: 0.5rem;
                font-size: 1rem;
                outline: none;
                color: var(--text-color);
                background: transparent;
            }

        .button {
            padding: 0.5rem 1rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
        }

            .button:hover {
                background: var(--secondary-color);
            }

            .button:active {
                transform: translateY(1px);
            }

            .button:disabled {
                background: var(--border-color);
                cursor: not-allowed;
            }

        .toolbar {
            background: var(--surface-color);
            padding: 0.5rem;
            border-radius: 8px 8px 0 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

            .toolbar button {
                padding: 0.5rem;
                background: none;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                cursor: pointer;
                color: var(--text-color);
                transition: all 0.2s;
            }

                .toolbar button:hover {
                    background: var(--background-color);
                }

                .toolbar button:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }

        .page-info {
            margin-left: auto;
            font-size: 0.875rem;
            color: var(--text-color);
            opacity: 0.8;
        }

        .content-container {
            background: var(--surface-color);
            border-radius: 0 0 8px 8px;
            overflow: hidden;
            height: calc(100vh - 160px);
            position: relative;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        #content-frame {
            width: 100%;
            height: 100%;
            border: none;
            background: white;
            display: none;
        }

        .loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

            .loader::after {
                content: '';
                display: block;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: 3px solid var(--border-color);
                border-top-color: var(--primary-color);
                animation: spin 1s linear infinite;
            }

        .status {
            padding: 0.75rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            display: none;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

            .status.success {
                background-color: #dcfce7;
                color: var(--success-color);
                border: 1px solid #86efac;
            }

            .status.error {
                background-color: #fee2e2;
                color: var(--error-color);
                border: 1px solid #fca5a5;
            }

            .status.info {
                background-color: #dbeafe;
                color: var(--primary-color);
                border: 1px solid #93c5fd;
            }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
            }

            .control-panel {
                flex-direction: column;
            }

            .header h1 {
                font-size: 1.25rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <i class="fas fa-globe"></i>
                Web Proxy Viewer
            </h1>
            <div class="control-panel">
                <div class="url-input">
                    <i class="fas fa-link"></i>
                    <input type="text" id="url-input" placeholder="Enter website URL (e.g., https://example.com)" autocomplete="off">
                </div>
                <button id="load-button" onclick="loadUrl()" class="button">
                    <i class="fas fa-arrow-right"></i>
                    Load Page
                </button>
            </div>
            <div id="status" class="status"></div>
        </div>

        <div class="toolbar">
            <button onclick="reloadPage()" title="Reload" id="reload-button">
                <i class="fas fa-redo"></i>
            </button>
            <button onclick="goBack()" title="Back" id="back-button">
                <i class="fas fa-arrow-left"></i>
            </button>
            <button onclick="goForward()" title="Forward" id="forward-button">
                <i class="fas fa-arrow-right"></i>
            </button>
            <div class="page-info" id="page-info"></div>
        </div>

        <div class="content-container">
            <div class="loader" id="loader"></div>
            <iframe id="content-frame" sandbox="allow-same-origin allow-scripts allow-forms"></iframe>
        </div>
    </div>

    <script>
        let currentUrl = '';
        let history = [];
        let historyIndex = -1;
        let peer;
        let conn;
        let requestId = 0;
        let pendingRequests = new Map();
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const pageCache = new Map();
        const maxCacheSize = 50;
        const cacheTTL = 30 * 60 * 1000; // 30分

        function enableButtons(enabled) {
            const buttons = ['load-button', 'reload-button', 'back-button', 'forward-button'];
            buttons.forEach(id => {
                const button = document.getElementById(id);
                button.disabled = !enabled;
            });
            document.getElementById('url-input').disabled = !enabled;
        }

        function updateNavigationButtons() {
            document.getElementById('back-button').disabled = historyIndex <= 0;
            document.getElementById('forward-button').disabled = historyIndex >= history.length - 1;
            document.getElementById('reload-button').disabled = !currentUrl;
        }

        async function initializePeerConnection() {
            if (peer) {
                peer.destroy();
            }

            peer = new Peer(null, {
                debug: 2,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                }
            });

            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('Connection timeout'));
                }, 10000);

                peer.on('open', () => {
                    clearTimeout(timeout);
                    reconnectAttempts = 0;
                    connectToServer();
                    resolve();
                });

                peer.on('error', (error) => {
                    clearTimeout(timeout);
                    console.error('Peer error:', error);
                    showStatus(`Connection error: ${error.message}`, 'error');
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        setTimeout(() => {
                            initializePeerConnection().catch(console.error);
                        }, 2000 * reconnectAttempts);
                    }
                    reject(error);
                });
            });
        }

        function connectToServer() {
            if (conn) {
                conn.close();
            }

            conn = peer.connect('proxy-server', {
                reliable: true,
                serialization: 'json'
            });

            showStatus('Connecting to proxy server...', 'info');

            conn.on('open', () => {
                showStatus('Connected to proxy server', 'success');
                enableButtons(true);
            });

            conn.on('data', (response) => {
                const request = pendingRequests.get(response.id);
                if (request) {
                    pendingRequests.delete(response.id);
                    if (response.success) {
                        request.resolve(response.data);
                    } else {
                        request.reject(new Error(response.error));
                    }
                }
            });

            conn.on('error', (error) => {
                console.error('Connection error:', error);
                showStatus(`Connection error: ${error.message}`, 'error');
                enableButtons(false);
            });

            conn.on('close', () => {
                showStatus('Disconnected from proxy server', 'error');
                enableButtons(false);
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    setTimeout(connectToServer, 2000 * reconnectAttempts);
                }
            });
        }

        async function sendRequest(url) {
            if (!conn || !conn.open) {
                throw new Error('Not connected to proxy server');
            }

            return new Promise((resolve, reject) => {
                const id = requestId++;
                const timeout = setTimeout(() => {
                    pendingRequests.delete(id);
                    reject(new Error('Request timeout'));
                }, 30000);

                pendingRequests.set(id, {
                    resolve: (data) => {
                        clearTimeout(timeout);
                        resolve(data);
                    },
                    reject: (error) => {
                        clearTimeout(timeout);
                        reject(error);
                    }
                });

                conn.send({ id, url });
            });
        }

        function renderPage(data) {
            const frame = document.getElementById('content-frame');
            const frameDoc = frame.contentDocument || frame.contentWindow.document;

            const minimalHTML = `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <base href="${data.url}">
                        <style>
                            html, body {
                                margin: 0;
                                padding: 0;
                                width: 100%;
                                height: 100%;
                            }
                            body {
                                transform: scale(0.8);
                                transform-origin: top left;
                                width: 125%;
                            }
                            img {
                                max-width: 100%;
                                height: auto;
                            }
                        </style>
                    </head>
                    <body>${data.html}</body>
                    </html>
                `;

            frameDoc.open();
            frameDoc.write(minimalHTML);
            frameDoc.close();

            if (data.viewport) {
                frameDoc.documentElement.style.width = data.viewport.width + 'px';
                frameDoc.documentElement.style.height = data.viewport.height + 'px';
            }

            frame.onload = () => {
                try {
                    const frameWindow = frame.contentWindow;
                    if (data.viewport) {
                        frameWindow.scrollTo(
                            data.viewport.pageXOffset || 0,
                            data.viewport.pageYOffset || 0
                        );
                    }
                } catch (e) {
                    console.warn('Failed to restore scroll position:', e);
                }
            };
        }

        function cleanCache() {
            const now = Date.now();
            for (const [key, { timestamp }] of pageCache) {
                if (now - timestamp > cacheTTL) {
                    pageCache.delete(key);
                }
            }
            if (pageCache.size > maxCacheSize) {
                const sortedEntries = Array.from(pageCache.entries())
                    .sort(([, a], [, b]) => a.timestamp - b.timestamp);
                const entriesToDelete = sortedEntries.slice(0, pageCache.size - maxCacheSize);
                for (const [key] of entriesToDelete) {
                    pageCache.delete(key);
                }
            }
        }

        async function loadUrl(url) {
            const urlInput = document.getElementById('url-input');
            const status = document.getElementById('status');
            const loader = document.getElementById('loader');
            const frame = document.getElementById('content-frame');

            url = url || urlInput.value.trim();

            if (!url) {
                showStatus('Please enter a URL', 'error');
                return;
            }

            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'https://' + url;
                urlInput.value = url;
            }

            try {
                enableButtons(false);
                loader.style.display = 'block';
                frame.style.display = 'none';
                status.style.display = 'none';

                // キャッシュをチェック
                const cachedData = pageCache.get(url);
                if (cachedData && (Date.now() - cachedData.timestamp < cacheTTL)) {
                    renderPage(cachedData.data);
                    frame.style.display = 'block';
                    loader.style.display = 'none';
                    showStatus('Page loaded from cache', 'success');
                    updateHistory(url, cachedData.data.title);
                    enableButtons(true);
                    return;
                }

                const data = await sendRequest(url);
                if (!data) {
                    throw new Error('Invalid response from server');
                }

                // キャッシュを更新
                cleanCache();
                pageCache.set(url, {
                    data,
                    timestamp: Date.now()
                });

                renderPage(data);
                frame.style.display = 'block';
                loader.style.display = 'none';
                showStatus('Page loaded successfully', 'success');

                updateHistory(url, data.title);

            } catch (error) {
                console.error('Error:', error);
                showStatus(`Error: ${error.message}`, 'error');
                loader.style.display = 'none';
            } finally {
                enableButtons(true);
                updateNavigationButtons();
            }
        }

        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.innerHTML = `
                    <i class="fas fa-${type === 'error' ? 'exclamation-circle' :
                    type === 'success' ? 'check-circle' :
                        'info-circle'}"></i> ${message}`;
            status.className = `status ${type}`;
            status.style.display = 'flex';

            if (type !== 'error') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }

        function updateHistory(url, title) {
            currentUrl = url;
            document.getElementById('page-info').textContent = title || url;

            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            history.push(url);
            historyIndex = history.length - 1;
            updateNavigationButtons();
        }

        function reloadPage() {
            if (currentUrl) {
                pageCache.delete(currentUrl); // キャッシュを強制的にクリア
                loadUrl(currentUrl);
            }
        }

        function goBack() {
            if (historyIndex > 0) {
                historyIndex--;
                loadUrl(history[historyIndex]);
            }
        }

        function goForward() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadUrl(history[historyIndex]);
            }
        }

        window.onload = async () => {
            enableButtons(false);
            try {
                await initializePeerConnection();
                enableButtons(true);
            } catch (error) {
                console.error('Failed to initialize connection:', error);
                showStatus('Failed to connect to proxy server. Please refresh the page.', 'error');
            }

            document.getElementById('url-input').addEventListener('keypress', function (event) {
                if (event.key === 'Enter') {
                    loadUrl();
                }
            });

            updateNavigationButtons();
        };

        // クリーンアップ処理
        window.onbeforeunload = () => {
            if (peer) {
                peer.destroy();
            }
        };
    </script>
</body>
</html>